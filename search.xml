<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android单元测试总结]]></title>
    <url>%2F2019%2F08%2F03%2FAndroid%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[当年做Launcher单元测试的总结的一些要点，回顾一下 简述参考资料: Android自动化测试–学习浅谈Android单元测试实践Android单元测试 - 如何开始？Android单元测试系列: java的单元测试比较详细，有MVP和一些流行框架的测试方法 Android有关的单元测试大体分为两类: 本地单元测试 运行在jvm上的测试框架，不需要Android环境 位于src/test/java gradle引入时使用testCompile 有Junit4、Mockito、Powermockito，Robolectric Android Instrumentation测试 运行在Android环境上的测试框架，依赖真机或都模拟器环境 代码位于src/androidTest/java gradle引入时使用androidTest有AndroidJUnitRunner，Espresso, UI Automator 各种框架简介: Junit4: 基础的Java单元测试 Mockito: 模拟测试的类，是一个工具类的集合，配置其它框架使用 Robolectric: JVM环境中模拟Android的环境，可以在不连接Android设备的情况下进行测试。听起来很美好，但使用起来不是很方便，还一堆坑，介绍文章: https://www.jianshu.com/p/d0bc9ebaaea1 Espresso: UI测试，适合白盒测试 UI Automator: UI测试，适合黑盒测试，测试组的自动化脚本应该就是基于这个写的 框架结构使用Android Instrumentation测试，测试代码写在src/androidTest/java目录下 使用到的框架有junit4, mockito, Instrumentation, uiautomator, espressogradle下的依赖方式: 12345678910defaultConfig &#123; testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"&#125;//dependencesandroidTestCompile libraries.mockitoAndroidandroidTestCompile libraries.testRunnerandroidTestCompile libraries.uiautomatorandroidTestCompile libraries.annotationsandroidTestCompile libraries.espresso 各框架的基本使用Junit4主要提供各种注解和断言最重要的注解@Test表明了测试的方式，根据根据方法上的注解，其执行顺序为@BeforeClass –&gt; @Before –&gt; @Test –&gt; @After –&gt; @AfterClass 断言一般常用assertNotNull, assertEquals等详细Api和使用见此博客:https://blog.csdn.net/qq_17766199/article/details/78243176 mockito用来模拟对象，脱离对Android Api依赖详细使用方法见: https://blog.csdn.net/qq_17766199/article/details/78450007 对于一些依赖的流程过多的测试可以用该方法隔离依赖: 例如LauncherAppState的初始化是在Launcher启动时，在样在测试依赖LauncherAppState的代码时就可以用mock来模拟对象，如: 12345678910Mock LauncherAppState mMockApp;Mock IconCache mMockIconCache;public void setUp() throws Exception &#123; super.setUp(); MockitoAnnotations.initMocks(this); when(mMockApp.getIconCache()).thenReturn(mMockIconCache); when(mMockApp.getContext()).thenReturn(mTargetContext);&#125; uiautomator主要进行UI测试，能够通过Id, text和description来查找元素，不限进程，使用方便，确点是只能获取到当前显示的最顶层Window上的view，对应着sdk下的uiautomatorviewer工具。 这个在自动化测试时也是一个重要的工具，可以针对Release版本进行测试，只是使用的jar包和shell脚本的方式做的。 使用时例如:UI Automator的Api主要包括三个方面 : UiDevice, UiObject/UiObject2, UiSelector/BySelector, UiObject和UiObject2功能一样，只是查找用的Selector不一样，一般都用比较方便的BySelector和UiObject2，例如: 123UiDevice mDevice = UiDevice.getInstance(InstrumentationRegistry.getInstrumentation());UiObject2 button = mDevice.findObject(By.text("text"))button.click() Espressouiautomator虽然使用很方便，但是还是有很多局限，无法获取到一些View的属性，也只能通过Assert来判断。这时就可以结合Espresso使用基本使用方法: https://www.jianshu.com/p/37f1897df3fd 下面是官方网站给出的一个例子， 123onView(withId(R.id.my_view)) .perform(click()) .check(matches(isDisplayed())); 可以自定义Matcher来检查更为复杂的属性 1234567891011121314151617181920212223242526272829final InvariantDeviceProfile idp = SettingDeviceProfile.getProfileById(gridSizeIds[index]);onView(withId(R.id.workspace)).check(matches(new TypeSafeMatcher&lt;View&gt;() &#123; Point reallySize = new Point(); Point targetSize = new Point(); @Override protected boolean matchesSafely(View item) &#123; if(!(item instanceof Workspace))&#123; return false; &#125; Workspace workspace = (Workspace) item; CellLayout page = workspace.getCurrentDropLayout(); reallySize.set(page.getCountX(), page.getCountY()); targetSize.set(idp.numColumns, idp.numRows); return page.getCountX() == idp.numColumns &amp;&amp; page.getCountY() == idp.numRows; &#125; @Override public void describeTo(Description description) &#123; description.appendText(" gridSizeId is ") .appendText(String.valueOf(idp.gridSizeId)) .appendText(", target is") .appendText(targetSize.toString()) .appendText(", really is ") .appendText(reallySize.toString()); &#125;&#125;)); 开发要点: 测试的包括两方面: 纯功能测试和UI测试。 纯功能测试不要涉及Ui，不能启动Launcher，也不能使用uiautomator和espresso，代码统一放在com.transsion.launcher.fun包下Ui测试，才uiautomator, espresso为辅，写到com.transsion.launcher.ui下 所有测试均继承BaseContextAndroidTest，使用这个基类提供的mTargetContext和mTargetPackage，要注意需要包名时不要使用BuildConfig.APPLICATION_ID,要使用基类提供的mTargetPackage 所有需要测试的类前面要加上@RunWith(AndroidJUnit4.class)的注解，测试方法加上@Test的注意，且必需为public的 有异常可在方法上加上throws Exception上抛出，尽量不要使用try catch 多使用assert进行断言 需要Launcher对象，可以定义新建LauncherActivityRule后获取，例如 123456 @Rule public LauncherActivityRule mActivityMonitor = new LauncherActivityRule(); @Test public void findFreezerIcon()&#123; mActivityMonitor.getActivity()&#125; 需要等待时使用waitForIdle或者Wait.sleep(); Wait.atMost()可以等待某一条件成立 uiautomator只能检查有限的属性，可检查的属性可从sdk/tools/uiautomatorviewer.bat来看 异步Api可通过CountDownLatch来等待 CountDownLatch是一个同步工具类，它允许一个或多个线程一直等待，直到其他线程的操作执行完后 再 执行。CountDownLatch提供countDown() 方法递减锁存器的计数，如果计数到达零，则释放所有等待的线程，例如: 1234567891011121314151617@Testpublic void testLoadWallpaper() throws InterruptedException &#123; final CountDownLatch latch = new CountDownLatch(1); final ArrayList&lt;LocalWallpaperInfo&gt; wallpaperInfos = new ArrayList&lt;&gt;(); GuideLoadPresenter.GuideUi ui = new GuideLoadPresenter.GuideUi() &#123; @Override public void loadComplete(ArrayList&lt;LocalWallpaperInfo&gt; infos, Drawable previewIcon) &#123; wallpaperInfos.addAll(infos); latch.countDown(); &#125; &#125;; GuideLoadPresenter presenter = new GuideLoadPresenter(ui); presenter.startLoad(mTargetContext, false); latch.await(20, TimeUnit.SECONDS); Assert.assertNotNull(ui);//GuideLoadPresenter内的ui是弱引用 Assert.assertThat(wallpaperInfos.size(), anyOf(is(1), is(2)));&#125; 测试点纯功能测试:由于Launcher各功能偶合性太强，可以写的测试用例有限，很多功能需要解偶才能写，这里建议多写工具方法的测试，如检测壁纸的util方法： AppLaunchCountRecorder 测试记录常用应用功能是否正常 GuideLoadPresenter 测试是否能够正确获取壁纸信息 LoadCursor 能否正常解析cursor中的数据 WallpaperUtils 测试能否正常获取壁纸及检查壁纸深浅 Ui测试，才uiautomator, espresso为辅 Settings界面 设置界面桌面提示 修改图标大小 选择桌面网格 图标锁定点击开关，相关设置是否禁用 A-Z界面移动方向切换，是否生效 文件颜色切换，是否生效 智能整理 关于XOS桌面几项功能跳转 AllApp界面 切换横向，竖向 竖向界面竖向滑动 竖向界面检查常用应用一栏 竖向界面是否有搜索框，点击搜索框能否弹出输入法 图标长按能否弹出菜单，发送到桌面 Launcher桌面 页面批量器， 检查是否与桌面页数匹配 拖动图标创建文件夹 拖动图标到文件夹 文件夹内左右滑动 文件夹重命名 点击打开文件夹添加界面 添加界面添加图标 长按空白处进入编辑模式 是否有冷藏室 冷藏室，冷藏解冻 安装，卸载应用(内置一个test的apk测试) 附录Activity基础测试类:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public class BaseUiAndroidTest extends BaseContextAndroidTest &#123; public static final long DEFAULT_UI_TIMEOUT = 1000L; public static final long DEFAULT_WAITTING_TIMEOUT = 5000L; protected Context mTargetContext; protected String mTargetPackage; UiDevice mDevice; /** * 初始化Context， Package等 */ @Before public void setUp() throws Exception &#123; mTargetContext = InstrumentationRegistry.getTargetContext(); mTargetPackage = mTargetContext.getPackageName(); mDevice = UiDevice.getInstance(InstrumentationRegistry.getInstrumentation()); &#125; protected String getText(@StringRes int resId)&#123; return mTargetContext.getResources().getString(resId); &#125; //启动Activity，且等打开完毕 public void startActivitySync(@NonNull Intent intent)&#123; mTargetContext.startActivity(intent); waitForIdle(); &#125; public void pressBack()&#123; mDevice.pressBack(); &#125; public void waitForIdle()&#123; mDevice.waitForIdle(); &#125; //通过id查找 protected UiObject2 findViewById(@IdRes int id) &#123; return mDevice.wait(Until.findObject(getSelectorForId(id)), DEFAULT_UI_TIMEOUT); &#125; protected UiObject2 findViewByText(@StringRes int resId)&#123; return findViewBySelector(By.text(getText(resId))); &#125; protected BySelector getSelectorForId(int id) &#123; String name = mTargetContext.getResources().getResourceEntryName(id); return By.res(mTargetPackage, name); &#125; protected UiObject2 findViewBySelector(BySelector condition)&#123; return mDevice.wait(Until.findObject(condition), DEFAULT_UI_TIMEOUT); &#125; //滚动查找元素 protected UiObject2 scrollAndFind(UiObject2 container, BySelector condition) &#123; do &#123; UiObject2 widget = container.findObject(condition); if (widget != null) &#123; return widget; &#125; &#125; while (container.scroll(Direction.DOWN, 1f)); return container.findObject(condition); &#125; protected UiObject2 scrollPageAndFind(UiObject2 container, BySelector condition) &#123; do &#123; UiObject2 widget = container.findObject(condition); if (widget != null) &#123; return widget; &#125; &#125; while (container.scroll(Direction.RIGHT, 1f)); return container.findObject(condition); &#125;&#125;]]></content>
      <tags>
        <tag>Android 单元测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android仿IOS打开应用进出场动画开发]]></title>
    <url>%2F2019%2F07%2F30%2FAndroid%E4%BB%BFIOS%E6%89%93%E5%BC%80%E5%BA%94%E7%94%A8%E8%BF%9B%E5%87%BA%E5%9C%BA%E5%8A%A8%E7%94%BB%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[3年前开发Rom时的一个任务，就是仿照IOS打开应用和退出应用的开发过程和思路，可能已经过时，现在拿出来看看以前的思路 目标最终效果做到如下的形式: 点击Launcher上的icon，app从Icon的位置开始放大到全屏，观察发现Launcher也有从Icon位置放大的效果;退场时，app界面和Launcher同时缩小到Icon位置 设置方法的选择:进出场动画和转场动画的本质是一样,都是从一个activity过渡到另一个activity的动画,所不同是进出场动画是在两个app之间的过渡，而且Launcher所在的activity是一个壁纸窗口，这是使用的时候需要注意的。 三种方法 设置theme中的 android:windowAnimationStyle这是最简单方便的方式，只需要我们配置几个动画的xml就ok了，缺点是由于是在主题的里面的静态资源，不能根据实际情况改变动画类型和和设置相关参数。诸多条件限制决定了这种方式不能达到目的。 overridePendingTransition方式这种方式可以让我们覆盖掉第一种方式设置的动画，优点是我们可以在代码里面动态改变它，但遗憾的是这个方法只受动画的xml文件形式，也无法接受设置动画的参数。 ActivityOptions方式这种方法是在startActivity的时候，通过ActivityOptions构造出一个Bundle参数，传递给WindowManager，用来覆盖默认的动画，这样就为我们定义转场动画提供了扩展空间。实际查看Launcher的源代码，原生也是这么做的。 准备进出场动画的设置流程主要与AMS和WMS有关，主要参考以下博客:android Application Component研究之Activity(二) WindowManagerService动画分析 为了更好的分析动画的设置流程，需要打开WMS和AMS的日志开关通过adb shell dumpsys window -d enable a打开WMS的日志开关通过adb shell dumpsys activity log a on打开AMS的日志开关 进场动画首先观察进场动画：点击APP的Icon后，整个界面从Icon位置放大，Icon放大到一定程度后可以隐约看到APP的界面，继续放大，app界面逐渐从透明到不透明，最终覆盖全屏。 Android原生通过ActivityOptions提供了一个类似的转场动画makeScaleUpAnimation，它的使用如下: 12ActivityOptions opts = ActivityOptions.makeScaleUpAnimation(v, left, top , width , height);startActivity(intent, opts.toBundle()); 其效果出来只有app放大，而Launcher没有动画效果，找遍资料可以发现android没有提供相关接口。 查看makeScaleUpAnimation方法的源码:12345678910111213public static ActivityOptions makeScaleUpAnimation(View source, int startX, int startY, int width, int height) &#123; ActivityOptions opts = new ActivityOptions(); opts.mPackageName = source.getContext().getPackageName(); opts.mAnimationType = ANIM_SCALE_UP; int[] pts = new int[2]; source.getLocationOnScreen(pts); opts.mStartX = pts[0] + startX; opts.mStartY = pts[1] + startY; opts.mWidth = width; opts.mHeight = height; return opts;&#125; 发现里面并没有构造一个Animation,只是设置了相关位置的相关参数，以及ANIM_SCALE_UP这个动画类型的标识，真正构造动画的方法在com.android.server.wm.AppTransition里面，这是一个协助WindowManagerServervice来设置转场动画的类。当真正需要执行动画时，会从AppTransition中加载或构造合适的动画，交由WindowManagerServervice来执行。 AppTransition每次会加载两个动画，一个是打开(enter)动画，另一个是退出(exit)动画，从Launcher打开Activity，对Activity来说是enter，对Launcher就是exit，加载ScaleUp的动画都会调用AppTransition的createScaleUpAnimationLocked: 123456789private Animation createScaleUpAnimationLocked(int transit, boolean enter,int appWidth, int appHeight) &#123; Animation a = null; if (enter) &#123; ... &#125;else&#123; ... &#125; return a;&#125; 这个方法有几个参数: transit: 表示本次过渡动画的类型, 由于Laucher是壁纸窗口,所以此时transit的值为TRANSIT_WALLPAPER_CLOSE enter:表示该窗口时进入还是退出,后来加载动画的时候调用两次createScaleUpAnimationLocked,两次就是这个参数值不同，一次为true，一次为false appWidth, appHeight:顾名思义，为app最终的宽高 createScaleUpAnimationLocked可以看到进入enter=true时的动画，其实就是两个动画的组合，一个放大动画ScaleAnimation，一个透明度变化动画(AlphaAnimation)，这就是App打开时的动画，而enter=false时，这时加载的应该是App打开时Launcher的动画，却只有透明度变化(AlphaAnimation)，仿照app放大的动画写一个launcher放大的动画即可: 先看app放大的动画:12345678910111213141516171819202122232425262728if (enter) &#123; // Entering app zooms out from the center of the initial rect. float scaleW = mNextAppTransitionStartWidth / (float) appWidth; float scaleH = mNextAppTransitionStartHeight / (float) appHeight; Animation scale = new ScaleAnimation(scaleW, 1, scaleH, 1, computePivot(mNextAppTransitionStartX, scaleW), computePivot(mNextAppTransitionStartY, scaleH)); //modify start if(XOS_LANCHER_TRANSITION &amp;&amp; transit == TRANSIT_WALLPAPER_CLOSE)&#123; scale.setInterpolator(mDecelerateXLauncherInterpolator); &#125;else&#123; scale.setInterpolator(mDecelerateInterpolator); &#125; //modify end Animation alpha = new AlphaAnimation(0, 1); //modify start if(XOS_LANCHER_TRANSITION &amp;&amp; transit == TRANSIT_WALLPAPER_CLOSE)&#123; alpha.setInterpolator(mThumbnailXLauncherFadeInInterpolator); &#125;else&#123; alpha.setInterpolator(mThumbnailFadeOutInterpolator); &#125; // modify end AnimationSet set = new AnimationSet(false); set.addAnimation(scale); set.addAnimation(alpha); set.setDetachWallpaper(true); a = set;&#125; 这时我更换了原来的两个动画的Interpolator，其中mDecelerateXLauncherInterpolator = new DecelerateInterpolator(2.5f)，将放大动画速度的因子调大，以便使减速过程更明显 1234567891011mThumbnailXLauncherFadeInInterpolator = new Interpolator() &#123; @Override public float getInterpolation(float input) &#123; // Linear response for first fraction, then complete after that. if (input &lt; RECENTS_THUMBNAIL_XLAUNCHER_FADEOUT_FRACTION) &#123; float t = input / RECENTS_THUMBNAIL_XLAUNCHER_FADEOUT_FRACTION; return mLinearOutSlowInInterpolator.getInterpolation(t); &#125; return 1f; &#125; &#125;; RECENTS_THUMBNAIL_XLAUNCHER_FADEOUT_FRACTION=0.15，这样以便app界面能够更快的将背景的Launcher界面上的Icon图标完全覆盖，不至于出现Launcher界面放大时看出变得很大的Icon图标 然后是Launcher的放大动画:12345678910111213141516171819202122if(XOS_LANCHER_TRANSITION &amp;&amp; transit == TRANSIT_WALLPAPER_CLOSE)&#123; //enter app : animation for launcher exit //mNextAppTransitionStartWidth,mNextAppTransitionStartHeight 是通过StartActivity传入的APP Icon的宽高，appWidth，appHeight是app全屏的时的大小 float scaleW = mNextAppTransitionStartWidth / (float) appWidth; float scaleH = mNextAppTransitionStartHeight / (float) appHeight; //因为对Launcher来说是从原来的大小放大，所以最终的大小是scaleW和scaleH的倒数 float sW = scaleW &gt; 0.001 ? 1 / scaleW : 1000f; float sH = scaleH &gt; 0.001 ? 1 / scaleH : 1000f; //第三和第四个参数是缩放点的中心位置，计算方法和app放大的位置相同，这样才能保证 Animation scale = new ScaleAnimation(1f, sW, 1f, sH, computePivot(mNextAppTransitionStartX, scaleW), computePivot(mNextAppTransitionStartY, scaleH)); scale.setInterpolator(mDecelerateInterpolator); Animation alpha = new AlphaAnimation(1f, 0.0f); alpha.setDuration(300); alpha.setInterpolator(mThumbnailFadeOutInterpolator); AnimationSet set = new AnimationSet(false); set.addAnimation(scale); set.addAnimation(alpha); set.setDetachWallpaper(true); a = set;&#125; 经过这几步修改，进场动画基本完成总结: ActivityOptions.makeScaleUpAnimation来实现需要的放大动画 原来的App放大的动画需要调整Interpolator，即放大动画和透明度动画的变化速率 加载Launcher动画时也需要调用createScaleUpAnimationLocked方法，只是传入的enter值为false Launcher的动画缩放中心位置和App缩放动画是相同的，但是放大倍数是相反的 退场动画进场动画可以通过startActivity(intent, opts.toBundle());传参数到AppTransition类中构造对应的方法，而退场时却没有对应的方法，这时候面临几个问题: 怎么设置退场动画 什么时候来设置退场动画 退场动画的位置参数从哪里来 这里看一下进场动画时的设置流程: 可以看到是ActivityStack在执行Resume的流程时一步步将ScaleUp的相关参数设置到AppTranssion中去的。所以可以仿照这个流程在WindowMamagerService和AppTransition中添加一个overridePendingAppTransitionScaleUp方法:WindowMamagerService中添加: 123456public void overridePendingAppTransitionScaleDown(int startX, int startY, int startWidth, int startHeight) &#123; synchronized(mWindowMap) &#123; mAppTransition.overridePendingAppTransitionScaleDown(startX, startY, startWidth,startHeight); &#125; &#125; AppTransition中添加:1234567891011121314void overridePendingAppTransitionScaleDown(int startX, int startY, int startWidth, int startHeight) &#123; if (isTransitionSet()) &#123; mNextAppTransitionType = NEXT_TRANSIT_TYPE_SCALE_DOWN; mNextAppTransitionPackage = null; mNextAppTransitionThumbnail = null; mNextAppTransitionStartX = startX; mNextAppTransitionStartY = startY; mNextAppTransitionStartWidth = startWidth; mNextAppTransitionStartHeight = startHeight; postAnimationCallback(); mNextAppTransitionCallback = null; &#125;&#125; NEXT_TRANSIT_TYPE_SCALE_DOWN是我自定义的一个动画，用来表示退场的动画AppTransition类中添加: 1234567891011121314151617181920 Animation loadAnimation(WindowManager.LayoutParams lp, int transit, boolean enter, int appWidth, int appHeight, int orientation, Rect containingFrame, Rect contentInsets, Rect appFrame, boolean isVoiceInteraction) &#123; .... // add start &#125; else if(XOS_LANCHER_TRANSITION &amp;&amp; transit == TRANSIT_WALLPAPER_OPEN &amp;&amp; mNextAppTransitionType == NEXT_TRANSIT_TYPE_SCALE_DOWN)&#123; a = createScaleDownAnimationLocked(transit, enter, appWidth, appHeight);if (DEBUG_APP_TRANSITIONS || DEBUG_ANIM) Slog.v(TAG, "applyAnimation:" + " anim=" + a + " nextAppTransition=ANIM_SCALE_DOWN" + " transit=" + appTransitionToString(transit) + " isEntrance=" + enter + " Callers=" + Debug.getCallers(3)); //add end &#125; ....&#125;...private Animation createScaleDownAnimationLocked(int transit, boolean enter,int appWidth, int appHeight) &#123; ....&#125; loadAnimation用来选择加载哪个动画，而createScaleDownAnimationLocked便是真正实现的地方了，也是最重要的地方，需要反复微调效果，放在最后说。 怎么设置怎么设置退场动画解决了，但是什么时候来设置它呢？通过分析log发现，不管进场还是退场的时候其实都会执行一次AcitivityStack的resumeTopActivityInnerLocked，通过ActivityRecord.applyOptionsLocked来试图设置过场动画，只是AcitivityOption在用完一次后就置null了，以后无法再次使用，为达到目的，需要将进场时的AcitivityOption保存起来。这里不能将AcitivityOptions保存在ActivityRecord里面，因为一个AcitivityRecord会对应一个Acitivity，而我们打开app可能会打开多个Activity，退出的时候很有可能不是从进来的Activity退出的。这时候就需要将ActivityOptions保存在Task即TaskRecord中 所以我思路是这样的: 打开app的时候，判断前一个Activity是否是Launcher，表示是从launcher打开app，是的话将AcitivityOptions保存到当前app所在的TaskRecord 退出app的时候，判断后一个Activity是否是Launcher，表示退出app，是的话将AcitivityOptions参数从前一个TaskRecord中取出来放入Launcher所在ActivityRecord，这样ActivityRecord就有参数来设置退场动画了 但是在实际操作过程中遇到一个问题，如果将上述的操作放在resumeTopActivityInnerLocked中会在很多情况下这个方法是取不到前一个ActivityRecord的对象的，但这些操作又要放在resumeTopActivityInnerLocked之前。这里思考到在Acitivity resume之前，肯定会执行前一个Activity的pause操作，最后到找一个合适的保存参数的位置即startPausingLocked 123456789101112131415161718192021222324252627282930313233343536final boolean startPausingLocked(boolean userLeaving, boolean uiSleeping, boolean resuming,boolean dontWait) &#123; ... //add start final TaskRecord prevTask = prev != null ? prev.task : null; final TaskRecord nextTask = next != null ? next.task : null; if (DEBUG_STATES) Slog.v(TAG_STATES, "Moving to PAUSING: " + prev+";next:"+next+";prevTask:"+prevTask); if(XOS_LANCHER_TRANSITION &amp;&amp; prev != null &amp;&amp; prev.isHomeActivity())&#123; //前一个activity是Launcher是，将ActivityOptions保存到下一个TaskRecord中 ActivityOptions opt = next != null ? next.pendingOptions : null; if(opt != null &amp;&amp; opt.getAnimationType() == ActivityOptions.ANIM_SCALE_UP &amp;&amp; nextTask != null)&#123; nextTask.updatePendingOptions(opt); if(DEBUG_STATES)&#123; Slog.d(TAG_STATES,"resumeTopActivityLocked updatePendingOptions to task:"+opt); &#125; &#125; &#125; if(XOS_LANCHER_TRANSITION &amp;&amp; ((next != null &amp;&amp; next.isHomeActivity())||next == null))&#123; boolean maySkip = false; if(next == null)&#123; maySkip = PowerOffAlarmUtility.isAlarmBoot(); &#125; //会存在有些情况获取的下一个AcitivityRecord为null，这些问题nex都是为Launcher的 ActivityRecord homeRecord = next != null ? next : mStackSupervisor.getHomeActivity(); if(DEBUG_STATES)&#123; Slog.d(TAG_STATES,"resumeTopActivityLocked maySkip:"+maySkip+"; homeRecord:"+homeRecord); &#125; if(!maySkip &amp;&amp; homeRecord != null &amp;&amp; prevTask != null &amp;&amp; prevTask.mPendingOptions != null)&#123; homeRecord.updateScaleOptions(prevTask.mPendingOptions); if(DEBUG_STATES)&#123; Slog.d(TAG_STATES,"resumeTopActivityLocked updatePendingOptions restore from task:"+prevTask.mPendingOptions); &#125; &#125; &#125; //add end ...&#125; 这样我们都顺利的记住了进入App和退出App时的位置信息 接下来看AppTransition.createScaleDownAnimationLocked方法，它是退场动画的构造。与createScaleUpAnimationLocked所构造的动画是相反的。不过会有几个问题： 退场动画需要一个合适的减速过程才能达到理想的效果 经过反复试验，最终采用以(0.1,0),(0.1,1)为控制点的三阶贝塞尔曲线 放慢速度会发现，在退场动画时app界面会在Launcher界面下面，这样会感觉Icon图标变得很巨大，而没有给人App界面缩小，最后变成Icon的错觉 这个需要调试动画时App界面和Launcher界面的Z轴的层次，所以App动画需要设置set.setZAdjustment(Animation.ZORDER_TOP);,而Launcher的动画需要设置:set.setZAdjustment(Animation.ZORDER_NORMAL); 缩放时Launcher宽高缩放需要等比，不然会变形，但App的缩放注定又不是等比的，这样会导致App界面消失时由于比Icon而残影严重。最后通过单独调节Y轴方向上的缩放速率来减轻残影。 最后还有一个关键点，那就是app界面缩小时透明度的变化，它关系到在退场过程中能否给人感觉平滑过渡到Icon图标下面是调节透明度变化的Interpolator 123456789101112131415final Interpolator xInterploator = new DecelerateInterpolator(3f);mThumbnailXLauncherFadeOutInterpolator = new Interpolator() &#123; @Override public float getInterpolation(float input) &#123; // Linear response for first fraction, then complete after that. if(input &lt;= 0.10)&#123;//动画开始一段时间app界面保持完全透明 return 0f; &#125; if (input &lt;= 0.95f) &#123; float t = (input - 0.10f)/ 0.85f; return xInterploator.getInterpolation(t);//透明度变化经历一个减速过程 &#125; return 1f; &#125; &#125;; 最终createScaleDownAnimationLocked方法如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172private Animation createScaleDownAnimationLocked(int transit, boolean enter, int appWidth, int appHeight) &#123; //modify lancher_transition start int startWidth = mNextAppTransitionStartWidth ; int startHeight = mNextAppTransitionStartHeight ; int startX = mNextAppTransitionStartX ; int startY = mNextAppTransitionStartY ; if(startWidth == mAppIconSize)&#123;//需要对icon的大小进行一定的修正 int inset = 5 ; startWidth = startWidth - inset * 2; startHeight = startWidth; startX = startX + inset; startY = startY + inset; &#125; //modify end Animation a = null; if (!enter) &#123; // Exit app zooms out from the center of Launcher icon rect. //modify lancher_transition start float scaleW = startWidth / (float) appWidth; float scaleH = startHeight / (float) appHeight; Animation scale = new ScaleAnimation(1, scaleW, 1, 1, computePivot(startX, scaleW), computePivot(startY, scaleH)); scale.setInterpolator(mFastOutSlowInInterpolator); Animation scale2 = new ScaleAnimation(1, 1, 1, scaleH, computePivot(startX, scaleW), computePivot(startY, scaleH)); scale2.setInterpolator(mScaleDownYDecelerateInterpolator); //modify lancher_transition start Animation alpha = new AlphaAnimation(1, 0); alpha.setInterpolator(mThumbnailXLauncherFadeOutInterpolator); AnimationSet set = new AnimationSet(false); set.addAnimation(scale); set.addAnimation(scale2); set.addAnimation(alpha); set.setDetachWallpaper(true); set.setZAdjustment(Animation.ZORDER_TOP); a = set; &#125;else&#123; float scaleW = startWidth / (float) appWidth; float scaleH = startHeight / (float) appHeight; float sW = scaleW &gt; 0.001 ? 1 / scaleW : 1000f; float sH = scaleH &gt; 0.001 ? 1 / scaleH : 1000f; if(startWidth == startHeight)&#123; sW = Math.min(sW,sH); sH = sW;//保存Laucher是等比缩放 &#125; Animation scale = new ScaleAnimation(sW, 1f, sH, 1f, computePivot(startX, scaleW), computePivot(startY, scaleH)); scale.setInterpolator(mFastOutSlowInInterpolator); Animation alpha = new AlphaAnimation(0.0f, 1f); alpha.setInterpolator(mThumbnailFadeOutInterpolator); AnimationSet set = new AnimationSet(false); set.addAnimation(scale); set.addAnimation(alpha); set.setDetachWallpaper(true); set.setZAdjustment(Animation.ZORDER_NORMAL); //modify lancher_transition end a = set; &#125; long duration = 380L; //modify lancher_transition start a.setDuration(duration); a.setFillAfter(true); a.setInterpolator(mDecelerateInterpolator); a.initialize(appWidth, appHeight, appWidth, appHeight); return a; &#125; 不足之处主要表现在退场时不够完美 退场时app界面的残影仍然存在，在Icon图标不为方形时明显 由于只app退出时只能回到进场时点击的位置，所以当Launcher上的app图标改变了，然后从任务列表进入app界面，再退出是无法缩放到正确的位置的。]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Electron笔记]]></title>
    <url>%2F2018%2F07%2F07%2FElectron%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[参考: 官网: https://electronjs.org/docsElectron: 从零开始写一个记事本app 环境安装安装node.js : https://nodejs.org/en/ 安装npm： npm可能用不了，可以用cnpm, 官网https://npm.taobao.org/安装命令: 1npm install -g cnpm --registry=https://registry.npm.taobao.org 安装electron包: 123&gt;cnpm install -g electronOR&gt;npm install electron -g 验证electron安装成功: 运行electron 安装Electron-forge这是一个类似于傻瓜开发包的Electron工具整合项目。具体介绍点击 这里。1cnpm install -g electron-forge 新建项目通过以下命令创建项目:1electron-forge init [项目名]]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android Studio 上传代码到Maven仓库]]></title>
    <url>%2F2018%2F07%2F04%2FAndroid-Studio-%E4%B8%8A%E4%BC%A0%E4%BB%A3%E7%A0%81%E5%88%B0Maven%E4%BB%93%E5%BA%93%2F</url>
    <content type="text"><![CDATA[将自己的代码库上传到Maven一般有几个选择: 本地仓库 自己搭建的maven私有仓库, 如: Nexus 上传到Maven 上传到jcenter 上传到jitpack，这个上传很方便，比较推荐 参考Android Studio上传项目到Maven仓库 几点注意 上传library不能引用aar 配置了publishNonDefault true会引用上传时将Release和Debug的aar都上传到Maven，所以要么去除要么按照下面的方法配置 注意如果上传到snapshots测试仓库中，version必须以-SNAPSHOT结尾 Gradle上传配置1234567891011121314151617181920212223apply plugin: "maven"def compileMode = 1//分别为正式仓库，测试仓库和本地仓库，def releaseUrl = "http://192.168.1.78:8090/nexus/content/repositories/releases"def snapshotsUrl = "http://192.168.1.78:8090/nexus/content/repositories/snapshots/"def localUrl = 'file://' + new File(System.getProperty('user.home'), '.m2/repository').absolutePathdef uploadUrl = compileMode == 1 ? snapshotsUrl : compileMode == 2 ? localUrl : releaseUrluploadArchives &#123; repositories &#123; mavenDeployer &#123; repository(url: uploadUrl) &#123; authentication(userName: NAME, password: PASSWORD) // maven授权信息 &#125; pom.version = VERSION pom.artifactId = ARTIFACT_ID pom.groupId = GROUP_ID &#125; &#125;&#125; 注意如果上传到snapshots测试仓库中，version必须以-SNAPSHOT结尾 多flavor或多buildType配置maven上传是默认不支持多flavor的，如果library配置了publishNonDefault true, 在执行gradlew upload时会将releas和debug的aar包都上传上去，导致在引用时无法找到aar, 这点千万要注意, 需要修改gradle配置 123456789101112131415161718192021222324252627uploadArchives &#123; repositories &#123; mavenDeployer &#123; repository(url: uri(uploadUrl))&#123; //配置账号密码 authentication(userName: "userName", password: "password") &#125; android.libraryVariants.all &#123; variant -&gt; def isFlavor = !variant.flavorName.isEmpty() def isRelease = variant.buildType.name == "release" //只上传release的，如果没有多个flavor的去掉isFlavor的判断 if(isRelease &amp;&amp; isFlavor)&#123; def _flavorName = "$&#123;variant.flavorName&#125;" //此处需要再进行一次过滤，否则debug的会被上传上去 addFilter(_flavorName) &#123; artifact, file -&gt; (artifact.attributes.classifier == "$&#123;variant.flavorName&#125;Release") &#125; pom(_flavorName).version = android.defaultConfig.versionName pom(_flavorName).groupId = "ARTIFACT_ID" pom(_flavorName).artifactId = "GROUP_ID-$&#123;_flavorName&#125;" &#125; &#125; &#125; &#125;&#125; 将源码，java doc等一并上传12345678910111213141516171819202122232425262728// 指定编码tasks.withType(JavaCompile) &#123; options.encoding = "UTF-8"&#125; // 打包源码task sourcesJar(type: Jar) &#123; from android.sourceSets.main.java.srcDirs classifier = 'sources'&#125; task javadoc(type: Javadoc) &#123; failOnError false source = android.sourceSets.main.java.sourceFiles classpath += project.files(android.getBootClasspath().join(File.pathSeparator)) classpath += configurations.compile&#125; // 制作文档(Javadoc)task javadocJar(type: Jar, dependsOn: javadoc) &#123; classifier = 'javadoc' from javadoc.destinationDir&#125; artifacts &#123; archives sourcesJar archives javadocJar&#125; 上传jitpackjitpack网址:https://jitpack.io/ 添加jitpack的仓库引用: 1maven &#123; url 'https://jitpack.io' &#125;]]></content>
      <tags>
        <tag>Gradle</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android性能优化]]></title>
    <url>%2F2018%2F04%2F15%2FAndroid%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[工作几年，主要负责过InCallUI和Launcher，虽然不多，但在性能优化上还是有一些自己的经验和看法，在这里记录一下。 首先我认为性能优化最核心的思想就是提升用户体验，何谓体验? 可能不同的人有不同的答案.在我看来一定要站在用户角度才知道优化什么。有点杂乱，先记录要点， 以后再详细写： 启动速度。关键点是要把第一页的内容尽早展现给用户。初始化流程; 启动页白屏; 布局层次; 懒加载; cpu运行情况 流畅性。关键点是主线程的耗时流程。布局层次，布局重用，过度绘制，RecyclerView优化，动画优化，自定义布局和View，耗时操作移去子线程 内存。图片优化(不用过大的背景图，RGB555，使用Shape或适量图，tint涂色)，慎用三方库，及时释放不用的内存。 使用工具检测 TraceView找出耗时方法 log输出真正的耗时，方便对比优化前后 过度绘制显示绘制层次 布局查看器查看布局层次结构 Systrace查看流程度 CPU Profiler检查线程运行忙碌情况 Memory Profiler检查内存占用情况 Lint代码检查工具检查代码]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fragment笔记]]></title>
    <url>%2F2018%2F04%2F15%2FFragment%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[两年前的笔记，再拿出来回顾才发现许久不用有些内容都记混淆了 基本概念Fragment是Android3.0(sdk 17)后引入的一个新的API,出现的初衷是为了适应大屏幕的平板电脑,我们可以把他看成一个小型的Activity，又称Activity片段.Fragment并不能单独使用，必须嵌套在Activity中使用。 V4包下提供的也有一个Fragment,使用的时候要注意: 如果使用v4包下的Fragment,那么所在的那个Activity就要继承FragmentActivity AppCompatActivity下继承了FragmentActivity，可以直接使用 需要把getFragmentManager( )改成getSupportFragmentManager() 几个子类 对话框:DialogFragment列表:ListFragment选项设置:PreferenceFragmentWebView界面:WebViewFragment 生命周期: Fragment的生命周期是跟随Activity的 Fragment基本创建与使用静态加载 注意点:name属性是全限定类名哦，就是要包含Fragment的包名layout属性会覆盖fragment布局文件中的layout属性必须为布局设置id，系统在Activity恢复时用它来存储状态, 否则配置发生变化或内存重启时会报错(如旋转屏幕) 12345&lt;fragment android:id="@+id/fg_fragment" android:name="com.tory.demo.sample.test.LifeCycleFragment" android:layout_width="match_parent" android:layout_height="100dp"/&gt; 动态加载 注意点:Fragment的管理是通过事务来管理的，所以可以进行多次add,remove等注意事务需要commit 12345LifeCycleFragment fragment = new LifeCycleFragment();getSupportFragmentManager().beginTransaction() .add(R.id.frame_container,fragment,"LifeCycleFragment") .addToBackStack("LifeCycleFragment") .commit(); Fragment的事务操作 fragment的每一次改变的提交给activity，都称为一个事务add(), remove(),replace() ,show(), hide()等一系列方法，只有commit了以后才会生效Fragment的事务操作是异步的，commit了以后相当于进入了一个队列，然后等待合适的时刻执行 addToBackStack() 可以把fragment的本次操作放入Activity的返回栈中，通过点击back键可以回到以前状态，可以通过此方法移除或隐藏Fragment，个人不建议使用。 从FragmentManger.beginTransaction真正返回的确是一个BackStackRecord类， 其实现了FragmentTransaction所定义的接口。 使用技巧与建议: 对Fragment传递数据，建议使用setArguments(Bundle args)，而后在onCreate中使用getArguments()取出，在 “内存重启”前，系统会帮你保存数据，不会造成数据的丢失。和Activity的Intent原理一致。 使用newInstance(参数) 创建Fragment对象，优点是调用者只需要关系传递的哪些数据，而无需关心传递数据的Key是什么。可结合第一点使用 Fragment之间的通信，在同一个Activity下的两个Fragment的通信：FragmentA调用其宿主Activity的方法，宿主Activity再根据FragmentA的调用参数去调用FragmentB的方法并传递参数给B 在AS里面右键，新建Fragment, AS提供了一个Fragment的模板写法 使用newInstance(参数) 创建Fragment对象 使用setArguments(Bundle args)，而后在onCreate中使用getArguments()取出 在 “内存重启”前，系统会帮你保存数据，不会造成数据的丢失。和Activity的Intent原理一致。 在Fragment中定义一个内部回调接口,在Activity中实现 使用DialogFragment代码Dialog，便于管理Dialog的生命周期和保存状态。DialogFragment在show的时候容易出现以下错误java.lang.IllegalStateException: Fragment already added，这是重复添加引起的，fragment.isAdded() 123if(!fragment.isAdded())&#123; fragment.show(getFragmentManager(),"fragment");&#125; add(), show(), hide(), replace(),remove()…show()，hide()最终是让Fragment的View setVisibility()，不会调用生命周期;如: hide() 设置mHidden 为true fragment.mView.setVisibility(View.GONE); 隐藏fragment的view fragment.onHiddenChanged(true); 调用onHiddenChange可以发现也可能通过fragment.getView().setVisibility();来控制fragment的显示，只是此时没有改变mHidden的状态replace()的话会销毁前一个视图，即调用onDestoryView、onCreateView等一系列生命周期 onHiddenChanged的回调时机当使用add()+show()，hide()跳转新的Fragment时，旧的Fragment回调onHiddenChanged()，不会回调onStop()等生命周期方法，而新的Fragment在创建时是不会回调onHiddenChanged()，这点要切记。有类似需求可以自己实现 ViewPager中的Fragment生命周期ViewPager会预先加载预先加载包换当前可见的Fragment和其两侧的三个Fragment具体参考这篇文章：http://www.jianshu.com/p/660ec2666faa setUserVisibleHint使用ViewPager时，切换回上一个Fragment页面时（已经初始化完毕），不会回调任何生命周期方法以及onHiddenChanged()，只有setUserVisibleHint(boolean isVisibleToUser)会被回调，所以如果你想进行一些懒加载，可以重载该方法实现(需要配合fragment生命周期使用)。具体实现可以参考:http://www.jianshu.com/p/c5d29a0c3f4csetUserVisibleHint的回调实际上是由ViewPager触发的，与fragment的show，hide状态没有太大关系 commit(), commitNow() 和executePendingTransactions(); commit并不是立即执行的, 它会被发送到主线程的任务队列当中去, 当主线程准备好执行它的时候执行; 所以在使用commit的后要注意通过isAdded()或isShow()等方法是并不可靠的，因为很有可能因为Fragment还没到添加上去而引起一些错误。 想要同步执行可以使用commitNow或者executePendingTransactions; commitNow是立刻执行当前事务, 而executePendingTransactions立即执行在队列中的所有事务！ 使用中出现的问题:Activity重新创建通过事务动态添加Fragment的时候我们可能很自然的这样写 123456@OverrideonCreate(Bundle savedInstance) &#123; getSupportFragmentManager().beginTransaction() .add(R.id.frame_container,fragment) .commit();&#125; 表面上看起来没有什么情况，看起来好像也没有什么不对，但在实际项目中可以看到很多这样的写法 123456@OverrideonCreate(Bundle savedInstance) &#123; if (savedIntance == null) &#123; // create fragment and add it to Activity. &#125;&#125; 因为系统配置信息发生变化或内存重启的时候，系统会把Activity杀掉，然后再重新创建它。此时系统会尽可能的恢复以前的状态，所以以前添加的Fragment也会重新添加进去，也就没有必要重新创建一个Fragment;这种情况下会引发几个问题 Fragment对象的获取,这个可以在需要和时候通过findFragmentByTag或onAttachFragment获取，也可以通过自己写回调接口来实现。 Fragment的状态会丢失，丢失的原因是onCreate重新创建时，会调用Framgment的默认无参构造来创建Fragment对象。所以这也是为什么文档中说Fragment一定要有一个默认的构造函数，而且最好不要有带参数的构造函数，传参数要用setArguments。所以需要在onSaveInstanceState()时，把一些变量保存，然后在onCreate时恢复 hide、show问题，主要也是Fragment的状态会丢失问题引起的，因为恢复的所有的Fragment的都是以show状态恢复的，需要自己手动恢复其状态。这里是一个示例:http://www.jianshu.com/p/d9143a92ad94 123456789101112131415161718192021222324public class TestActivity extends Activity&#123; private static final String STATE_SAVE_IS_HIDDEN = "STATE_SAVE_IS_HIDDEN"; @Override public void onCreate(@Nullable Bundle savedInstanceState) &#123; ... if (savedInstanceState != null) &#123; boolean isSupportHidden = savedInstanceState.getBoolean(STATE_SAVE_IS_HIDDEN); FragmentTransaction ft = getFragmentManager().beginTransaction(); if (isSupportHidden) &#123; ft.hide(this); &#125; else &#123; ft.show(this); &#125; ft.commit(); &#125; @Override public void onSaveInstanceState(Bundle outState) &#123; ... outState.putBoolean(STATE_SAVE_IS_HIDDEN, isHidden()); &#125;&#125; state loss异常FragmentTransaction是异步的，commit()仅是相当于把操作加入到FragmentManager的队列，然后FragmentManager会在某一个时刻来执行，并不是立即执行。所以在实际项目中可能会偶尔出现这种报错:Can not perform this action after onSaveInstanceState。从这段报错信息可以猜测出我们commit()是onSaveInstanceState()之后了。出现这种情况有两种解决方案: 尽量要在onSaveInstanceState之前进行Fragment进行操作, 可以添加标志符解决参考Dialer 使用commitAllowStateLoss，它可以保证在Activity onStop以后仍然顺利执行commit操作，但是会造成状态丢失。 报错的原因见BackStackRecord.commitInternal -&gt; FragmentManager.enqueueAction ，即在commit的时候，FragmentManager通过checkStateLoss进行了一次状态检测在使用DilaogFragment的show和dissmiss方法时也要注意发生该异常的情况，建议使用dismissAllowingStateLoss方法 commitAllowingStateLoss会造成状态丢失，具体情况如下: 当前您的 Activity 在显示 FragmentA 您的 Activity 被切换到后台了（(onStop() 和 onSaveInstanceState() 函数被调用了） 这个时候您的 Activity 的逻辑发生了一些变化，您使用 FragmentB 替换了 FragmentA 并调用了 commitAllowingStateLoss() 函数来提交这个变化。 这个时候，当用户再次切回您的 Activity 的时候可能出现如下两种状态： 如果系统内存不足并且杀死了您的应用，当用户重新打开您的 应用的时候，系统将会恢复您的应用到上面第二步的状态，而 FragmentB 是不会显示的。 如果系统没有杀死您的应用，用户则可以看到 FragmentB。当 Activity 再次回到后台的时候（onStop）， FragmentB 的状态才会被保存起来。 文章我为什么主张反对使用Android Fragment]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git笔记]]></title>
    <url>%2F2018%2F03%2F23%2FGit%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[25个 Git 进阶技巧Git常用命令备忘 命令及技巧git log查看提交记录1234git log git log &lt;file&gt; # 查看该文件每次提交记录 git log -p &lt;file&gt; # 查看每次详细修改内容的git log -p -2 # 查看最近两次详细修改内容的git log --stat # 查看提交统计信息 git reflog查看被撤消的提交12#恢复git reset --hard [hash] git stash暂存git stash用好很强大 12345git stash #暂存修改，注意要先git addgit stash apply #应用暂存修改git stash pop #应用暂存修改并删除git stah list #查看暂存的修改git stash apply [stash@&#123;0&#125;] #应用指定的暂存修改 提交git commit --amend 添加到最后一次提交 推送远程正常情况下push 1git push origin master 第一次可以推送并关联默认分支1git push -u origin master 这样以后每次就可以只用通过git push来推送了 如果需要进行code review, 需要改成下面这样 1git push origin HEAD:refs/for/master refs/for/master需要经过code review之后才可以提交；refs/heads/master不需要code review 远程更新在pull代码的时候，最好加上–rebase1git pull --rebase 因为git pull –rebase因为se这个命令做了以下内容： 把你 commit 到本地仓库的内容，取出来放到暂存区(stash)（这时你的工作区是干净的，这样就不会产生冲突啦） 然后从远端拉取代码到本地，由于工作区是干净的，所以不会有冲突 从暂存区把你之前提交的内容取出来，跟拉下来的代码合并 git blame查看某一行代码的修改历史通过以下方法查看文件中每行的最近个性1git blame file_name 结果如： 10584cb5 (tory 2018-03-01 23:14:43 +0800 2) apply from: &quot;config.gradle&quot; 然后通过git show commitID 查看历史 或者: 在Android Studio中右键文件行号部分，选择Annotate git cherry-pickgit cherry-pick用于把另一个本地分支的commit修改应用到当前分支。 git cherry-pick简介 移除某文件夹的版本控制以bin目录为例，如果bin已经被加入到 先添加到.gitignore里面1bin/ 预览要删除的文件1git rm -r -n --cached "bin/" 执行命令:1git rm -r --cached "bin/" 提交并推送到远程 12git commit -m "remove bin folder all file out of control" //提交git push origin master //提交到远程服务器 分支管理1234567891011121314151617#查看分支#查看本地分支git branch#查看远程分支git branch -r#查看本地和远程分支git branch -a#创建分支git branch 分支名#切换git checkout 分支名#创建+切换分支git checkout -b 分支名#删除分支git branch -d 分支名 基本配置配置设置Git的user name和email： 12$ git config --global user.name "xxx"$ git config --global user.email "xxx@xxx.com" 初始化项目: 1git init SSH Keys生成ssh key： 1ssh-keygen 在~/.ssh/id_rsa.pub中把公钥复制到github的ssh key的配置项中 添加后，在终端（Terminal）中输入以下内容，测试与github的连接是否正常1ssh -T git@github.com oschina的则是输入以下内容:1ssh -T git@git.oschina.net 关联远程仓库 使用下面的bash命令，将Http方式的项目改成为SSH方式 关联添加远程地址1git remote add origin "你项目的的ssh地址" 重新设置远程地址12cd "你项目的目录文件夹"git remote set-url origin "你项目的的ssh地址" 设置commit模板在主目录下新建commit.template文件，填入以下内容 12BUG ID: ALHWWY-XXXX or noneDESCRIPTION: 修复xxx模块的xxx错误 然后设置提交模板 12git config --global commit.template ~/commit.templategit config --global core.editor vim #设置提交commit message的默认编辑器 Shadowscoks代理12git config --global http.proxy 'socks5://127.0.0.1:1080'git config --global https.proxy 'socks5://127.0.0.1:1080' 查看配置信息system（系统级别）-&gt;global（用户级别，也就是所有仓库）-&gt;local（当前仓库）12345678#查看系统configgit config --system --list#查看当前用户（global）配置git config --global --list#查看当前仓库配置信息（需要在仓库中使用）git config --local --list .gitignoreGitHub官方的所有.gitignore文件https://github.com/github/gitignore]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python基础]]></title>
    <url>%2F2018%2F03%2F21%2Fpython%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[参考 Python教程 - 廖雪峰的官方网站 python3-cookbook 中文教程及自动化测试介绍https://my.oschina.net/u/1433482/blog/634218?fromerr=oGg6OFhY Python的设计哲学是“优雅”、“明确”、“简单” Python开发者的哲学是“用一种方法，最好是只有一种方法来做一件事” 安装 Python有两个版本，一个是2.x版，一个是3.x版，这两个版本是不兼容的Python的官方网站下载Python 3.5对应的64位安装程序或32位安装程序特别要注意勾上Add Python 3.5 to PATH，然后点“Install Now”即可完成安装 安装两个版本的python： 123456# 使用默认版本的Pythonpy# 使用Python 27py -2# 使用Python 35py -3 pip命令 123py -m pip install itchat# 指定特定版本的pippy -3 -m pip install itchat 基础基本语法 #开头的语句是注释 冒号:结尾时，缩进的语句视为代码块，建议4个空格的缩进 大小写敏感 文件头标注12#!/usr/bin/env python3# -*- coding: utf-8 -*- 方法 输出print(&#39;The quick brown fox&#39;, &#39;jumps over&#39;, &#39;the lazy dog&#39;) 输入name = input(&#39;please enter your name: &#39;) Python允许用&#39;&#39;&#39;...&#39;&#39;&#39;的格式表示多行内容123print('''line1line2line3''') 数据类型 整数 浮点数 可以使用科学计数法，如1.23x109就是1.23e9 字符串 布尔值 只有True、False两种值(注意大小写) 布尔值可以用and、or和not运算 空值 None 不是0 两种除法 /除法计算结果是浮点数(即使是两个整数恰好整除) //称为地板除，两个整数的除法仍然是整数 Python的字符串 字符串是以Unicode编码的 ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符 encode()方法可以编码为指定的bytes，decode()把bytes变为str12345&gt;&gt;&gt; '中文'.encode('utf-8')b'\xe4\xb8\xad\xe6\x96\x87'&gt;&gt;&gt; b'\xe4\xb8\xad\xe6\x96\x87'.decode('utf-8')'中文' 要计算str包含多少个字符，可以用len()函数,要查看字节数可结合encode Python中，采用的格式化方式和C语言是一致的，用%实现，举例如下：12&gt;&gt;&gt; '%2d-%02d' % (3, 1)' 3-01' 定义函数 def语句，依次写出函数名、括号、括号中的参数和冒号: 如果你已经把my_abs()的函数定义保存为abstest.py文件了，那么，可以在该文件的当前目录下启动Python解释器，用from abstest import my_abs来导入my_abs()函数，注意abstest是文件名（不含.py扩展名） 12345def my_abs(x): if x &gt;= 0: return x else: return -x import用来导入包，如import math语句表示导入math包 函数可以快返回多个值 123456import mathdef move(x, y, step, angle=0): nx = x + step * math.cos(angle) ny = y - step * math.sin(angle) return nx, ny 可以传入默认参数，类似php,注意默认参数要为不可变对象 123456def power(x, n=2): s = 1 while n &gt; 0: n = n - 1 s = s * x return s *args是可变参数，args接收的是一个tuple；**kw是关键字参数，kw接收的是一个dict。 可变参数既可以直接传入func(1,2,3)，又可以先组装list或tuple，再通过*args传入：func(*(1, 2, 3))；关键字参数既可以直接传入：func(a=1,b=2)，又可以先组装dict，再通过**kw传入：func(**{&#39;a&#39;: 1, &#39;b&#39;: 2})。 高级特性 切片（Slice） L[0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3 L[-2,0]表示倒数 list,tuple,字符串者可以切片 列表生成式 要生成的元素x * x放到前面，后面跟for循环，就可以把list创建出来 12345&gt;&gt;&gt; [x * x for x in range(1, 11)][1, 4, 9, 16, 25, 36, 49, 64, 81, 100]#全排列&gt;&gt;&gt; [m + n for m in 'ABC' for n in 'XYZ']['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ'] isinstance函数可以判断一个变量是不是字符串，如 isinstance(x, str) 安装第三方模块必须先知道该库的名称，可以在官网或者pypi上搜索,例如pip install Pillow 处理图片 面向对象的编程 123456class Student(object): #表示Student类继承objec类 def __init__(self, name, score): #实例化类方法，第一个参数永远是self，表示实例自己 self.name = name self.score = score def print_score(self): //第一个参数必需是self，调用时不用传入 print('%s: %s' % (self.name, self.score)) 1234bart = Student('Bart Simpson', 59)lisa = Student('Lisa Simpson', 87)bart.print_score()lisa.print_score() class后面紧接着是类名，即Student，类名通常是大写开头的单词，紧接着是(object)，表示该类是从哪个类继承下来的 __init__ 方法用来创建实例,第一个参数永远是self，表示创建的实例本身，注意是两个下划线&quot;__&quot; 和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量self，并且，调用时，不用传递该参数 如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线__，在Python中，实例的变量名如果以__开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问 在Python中，变量名类似__xxx__的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以，不能用__name__、__score__这样的变量名。 三方模块pip修pip改镜像在unix和macos，创建配置文件路径为：$HOME/.pip/pip.conf在windows上，创建配置文件路径为：%HOME%\pip\pip.ini在建立的pip配置文件内加入： 12[global]index-url = https://pypi.doubanio.com/simple #这里使用的是豆瓣的镜像站点 网页下载器 urllib 官方 import urllib.request import http.cookiejar request 第三方 python 3.3 摸拟登录 小例 网页解析器 beautiful Soup第三方插件 下载 http://wwww.crummy.com/software/BeautifulSoup/ 安装: pip install beautifulsoup4 安装lxml解析器(可选)， pip install lxml 测试: import bs4 pip安装的时候总是超时，可以建个文件 ~/.pip/pip.conf, 内容如下12[global]index-url = http://pypi.v2ex.com/simple python3.4学习笔记(十七) 网络爬虫使用Beautifulsoup4抓取内容 Progressbar参考 http://python.jobbole.com/83976/ clone下来https://github.com/coagulant/progressbar-python3.git运行 git clone https://github.com/coagulant/progressbar-python3.git python setup.py install 安装Pillow1pip install Pillow 安装win32crypt下载路径https://pypi.python.org/pypi/pywin32https://sourceforge.net/projects/pywin32/files/pywin32/]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[n个无序数求第k大的数]]></title>
    <url>%2F2018%2F03%2F15%2Fn%E4%B8%AA%E6%97%A0%E5%BA%8F%E6%95%B0%E6%B1%82%E7%AC%ACk%E5%A4%A7%E7%9A%84%E6%95%B0%2F</url>
    <content type="text"><![CDATA[今天面试问到n个无序的库找出第k大的数，用最优的算法，想了半天只后只好回答用快速排序再求第k大的数，时间复杂度为O(nlogn)，但这显然不是最优算法，回来后查了一个，在此做个记录。主要参考: 寻找第k大的数 排序解决法排序再找第k大的数是最简单的解决方法，排序完成后再找只需要根据数据索引即可，时间复杂度是1 而排序最优的是快速排序(不是绝对的，与数组大小有关)，时间复杂度为O(nlogn)，所以最后的时间复杂度O(nlogn) 快速排序基本思想是数组中取任意一个值key，将大于key的值放在key右边，小于key的值放在key左边。key的左边和右边则都是有序的了，然后递归key值左右的子数组。具体代码见参考文章。 类快排解法采取快速排序的思想，快速排序中一个最重要的partition算法是这样的。 快速排序基本思想是数组中取任意一个值key，将大于key的值放在key右边，小于key的值放在key左边。key的左边和右边则都是有序的了 快排中的partition算法，返回key在数组中的位置，如果key的位置正好等于k-1，那么问题则得到解决，如果key的位置不等于k-1，可使用递归查找对应子数组。直到key的位置等于k-1，则找对问题的解。 此解法的效率值为N*lgK，由于K是常数，所以此解法效率值为N，优于排序解法 通俗的描述一下partition的过程 长度为n的数组，取出第1个数作为参考值m，从第n个数向前遍历 如果数小于m则将该数放到第一个数的位置，并记下索引j 再从第2个数向后遍历，如果数大于m，则将该数放到数组索引j的位置，并记下该数的索引i 再从数组索引j-1的位置向前遍历，如果数小于m，将该数放到数组索引i的位置，并记下此时的索引j 再次从i+1的位置向后遍历，循环3-4 最后空的就是m的位置，而且m左边的比m小，右边的比m大 最小堆解法要先了解堆排序: 堆排序及优先队列 先在此总结一下堆排序的特性 堆是一个完全二叉树的数据结构，最大堆是父节点上的值比子节点上的值大，反之则是最小堆 堆是以数组形式实现的，所以二及对中i节点的左子节点一定是2i+1，右子节点一定是2i+2，而且数组中 array.length/2 到 array.length - 1之间的节点，肯定是叶子节点，没有子节点 创建堆要逆序进行，也就是从array.length/2开始，这样才能保证父节点一定大于子节点 堆排序其实就是将创建好的堆的最根节点放到数组最后，然后再次从根节点创建最大堆的过程 根据最大堆的排序过程可以看到，每次都是从堆中选取最大的数放到数组，所以在要算出第k个数时就可以停止了。 123456789101112public static int findKByHeap(int[] array, int k) &#123; buildHeap(array, k); for (int i = k + 1; i &lt; array.length; i++) &#123; if (array[i] &gt; array[0]) &#123; int temp = array[i]; array[i] = array[0]; array[0] = temp; maxHeapify(array, k, 0); &#125; &#125; return array[0];&#125;]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TimeRecoder 写一个计算App性能耗时的工具类]]></title>
    <url>%2F2018%2F03%2F12%2FTimeRecoder-%E5%86%99%E4%B8%80%E4%B8%AA%E8%AE%A1%E7%AE%97App%E6%80%A7%E8%83%BD%E8%80%97%E6%97%B6%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[介绍性能优化中经常会遇到要计算某个方法的耗时，通过一些工具如traceview的确可以分析大概的性能瓶颈，但是它们分析出的耗时大都是经过一定程度放大过的，要知道真正的耗时还是需要打印log这里总结了一个工具类TimeRecoder，可以方便的打印耗时log它主要做到三件事 打印耗时 方便开关 计算多次操作的平均耗时 使用很方便，直接在计算耗时点的前后加上begin和end即可如： 1234567@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; TimeRecorder.begin("MainActivity#onCreate"); super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); TimeRecorder.end("MainActivity#onCreate");&#125; 其中begin和end中的字符串是惟一标识，会在打印log时输出如：1Demo MainActivity#onCreate time spent=137ms 这些log代码可以留在release的代码中，可以随时关闭:1TimeRecorder.setDebug(false); 如果不想写开关，这里还预留了一种adb的方式打开关闭log的方法：1234#开启$: adb shell setprop log.tag.time_recorder_log V#关闭$: adb shell setprop log.tag.time_recorder_log D 关于这种使用原理可参考: http://blog.csdn.net/qqxiaoqiang1573/article/details/72867776 //未完 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206public class TimeRecorder &#123; private static final String TAG = "Demo"; /** * release版下通过以下命令打印log，但是需要重启应用 * $: adb shell setprop log.tag.time_recorder_log V * 关闭命令: * $: adb shell setprop log.tag.time_recorder_log D */ public static final String TIME_RECORDER_LOG = "time_recorder_log"; /** * debug模式下打开log，但是如果放在library里面会失效，因为library编译的一直是release版 */ private static boolean ENABLED = BuildConfig.DEBUG || isPropertyEnabled(TIME_RECORDER_LOG); private static long t1; private static ArrayMap&lt;String, Long&gt; sTimeMap; private static ArrayMap&lt;String, CountValue&gt; sNanoCountTimeMap; public static boolean isPropertyEnabled(String propertyName) &#123; return Log.isLoggable(propertyName, Log.VERBOSE); &#125; public static void setDebug(boolean debug)&#123; ENABLED = debug; &#125; /** * * @param msg */ private static void logd(@NonNull String msg) &#123; //这里的TAG最好整个模块一个统一的 Log.d("APP", msg); &#125; /** * 开始记录时间较短的耗时情况 * 调用方式为： * &#123;@link #beginNanoCount(String)&#125;开始计时 -&gt; &#123;@link #pauseNanoCount(String)&#125; 暂停计时 * 以上重复调用 * -&gt; &#123;@link #endNanoCount(String, String)&#125; 输出总耗时情况 * * @param tag */ public static void beginNanoCount(@NonNull String tag)&#123; if(!ENABLED) return; ensureNanoCountTimeMap(); CountValue countValue = sNanoCountTimeMap.get(tag); if(countValue == null)&#123; countValue = new CountValue(); sNanoCountTimeMap.put(tag, countValue); countValue.eclipseTime = 0; countValue.count = 0; &#125; countValue.nanoTime = System.nanoTime(); &#125; /** * 暂停计时 * 调用方式为： * &#123;@link #beginNanoCount(String)&#125;开始计时 -&gt; &#123;@link #pauseNanoCount(String)&#125; 暂停计时 * 以上重复调用 * -&gt; &#123;@link #endNanoCount(String, String)&#125; 输出总耗时情况 * * @param tag */ public static void pauseNanoCount(@NonNull String tag)&#123; if(!ENABLED) return; ensureNanoCountTimeMap(); CountValue countValue = sNanoCountTimeMap.get(tag); if(countValue == null || countValue.nanoTime == 0)&#123; return; &#125; countValue.eclipseTime += System.nanoTime() - countValue.nanoTime; countValue.nanoTime = 0; countValue.count ++; &#125; /** * 输出耗时 &#123;@link #endNanoCount(String, String)&#125; * @param tag */ public static void endNanoCount(@NonNull String tag)&#123; endNanoCount(tag, null); &#125; /** * 输出耗时 * 调用方式为： * &#123;@link #beginNanoCount(String)&#125;开始计时 -&gt; &#123;@link #pauseNanoCount(String)&#125; 暂停计时 * 以上重复调用 * -&gt; &#123;@link #endNanoCount(String, String)&#125; 输出总耗时情况 * @param tag * @param call */ public static void endNanoCount(@NonNull String tag,@Nullable String call)&#123; if(!ENABLED) return; ensureNanoCountTimeMap(); CountValue countValue = sNanoCountTimeMap.get(tag); if(countValue == null || countValue.count &lt;= 0)&#123; return; &#125; logd(TAG+" "+ tag +" "+ (call == null ? "" : call) + " time spent=" + nanoToMillis(countValue.eclipseTime) + ", count=" + countValue.count + ", per time spent=" + nanoToMillis(countValue.eclipseTime / countValue.count)+"ms"); sNanoCountTimeMap.remove(tag); &#125; public static long nanoToMillis(long nanoTime)&#123; return nanoTime / 1000000L; &#125; /** * 开始记录时间，供临时开发调用 * 对应调用无参数的end或者一个参数的end * &#123;@link #end()&#125; */ public static void begin()&#123; if (ENABLED) &#123; t1 = currentTimeMillis(); &#125; &#125; public static long end()&#123; if (ENABLED) &#123; return currentTimeMillis() - t1; &#125; return 0; &#125; /** * 开始记录时间 * 对应调用两个参数的end * &#123;@link #end(String, String)&#125; * @param tag : 记录时间的惟一标识 */ public static void begin(@NonNull String tag)&#123; if (ENABLED) &#123; ensureTimeMap(); sTimeMap.put(tag, currentTimeMillis()); &#125; &#125; /** * 输出耗时 * &#123;@link #begin(String)&#125; * @param tag */ public static void end(@NonNull String tag)&#123; end(tag, null); &#125; /** * 输出耗时 * &#123;@link #begin(String)&#125; * @param tag 记录时间的惟一标识 * @param call :log输出内容,可以为空 */ public static void end(@NonNull String tag,@Nullable String call)&#123; if (ENABLED) &#123; ensureTimeMap(); Long timeStamp = sTimeMap.get(tag); if(timeStamp == null)&#123; return; &#125; logd(TAG + " "+tag +" "+ (call == null ? "" : call) + " time spent="+(currentTimeMillis() - timeStamp)+"ms"); sTimeMap.remove(tag); &#125; &#125; /** * 记录时间,可考虑以后使用其它单位 * @return */ private static long currentTimeMillis()&#123; return SystemClock.uptimeMillis(); &#125; private static void ensureTimeMap()&#123; if (ENABLED) &#123; if(sTimeMap == null)&#123; sTimeMap = new ArrayMap&lt;&gt;(); &#125; &#125; &#125; private static void ensureNanoCountTimeMap()&#123; if(ENABLED)&#123; if(sNanoCountTimeMap == null)&#123; sNanoCountTimeMap = new ArrayMap&lt;&gt;(); &#125; &#125; &#125; private static class CountValue&#123; int count; long nanoTime; long eclipseTime; &#125;&#125;]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态代理及原理思考]]></title>
    <url>%2F2018%2F03%2F11%2F%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%8F%8A%E5%8E%9F%E7%90%86%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[动态代理基础动态代理是在程序运行时动态创建一个代理类，实现的过程和静态代理一致，只是它是由反射实现的， 是AOP的基础 动态代理类不会继承被代理类的接口，而是实现InvocationHandler ，例如: 1234567891011121314151617181920212223class OwnerInvocationHandler implements InvocationHandler &#123; private PersonBean personBean; OwnerInvocationHandler(PersonBean personBean)&#123; this.personBean = personBean; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; try&#123; if(method.getName().startsWith("get"))&#123; return method.invoke(personBean,args); &#125;else if(method.getName().equals("setHotOrNotRating"))&#123; throw new IllegalAccessException(); &#125;else if(method.getName().startsWith("set"))&#123; return method.invoke(personBean,args); &#125; &#125;catch (InvalidParameterException e)&#123; e.printStackTrace(); &#125; return null; &#125;&#125; 我们关注的就只是invoke方法和被传入的被代理对象personBean创建代理类实例 1234PersonBean person = new PersonBeanImpl();(PersonBean) Proxy.newProxyInstance(person.getClass().getClassLoader(), person.getClass().getInterfaces(), new OwnerInvocationHandler(person)) 可以看到代理类是用反射实现的当然，也可以把创建过程写到动态代理类中 12345public static PersonBean newProxyInstance(PersonBean person)&#123; return (PersonBean) Proxy.newProxyInstance(person.getClass().getClassLoader(), person.getClass().getInterfaces(), new OwnerInvocationHandler(person))&#125; Retrofit中动态类的实现撇开动态代理模式不谈，可以看到，Proxy可以生成生成一个继承特定接口的类，而一个继承了该接口的实现类也不是必要的。 这时联想到Retrofit，它也是使用Proxy生成的 123456public interface GitHub &#123; @GET("/repos/&#123;owner&#125;/&#123;repo&#125;/contributors") Call&lt;List&lt;Contributor&gt;&gt; contributors( @Path("owner") String owner, @Path("repo") String repo); &#125; 1234567Retrofit retrofit = new Retrofit.Builder() .baseUrl(API_URL) .addConverterFactory(GsonConverterFactory.create()) .build();// Create an instance of our GitHub API interface.GitHub github = retrofit.create(GitHub.class); retrofit.create的实现123456789101112131415161718192021222324public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123; Utils.validateServiceInterface(service); if (validateEagerly) &#123; eagerlyValidateMethods(service); &#125; return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;, new InvocationHandler() &#123; private final Platform platform = Platform.get(); @Override public Object invoke(Object proxy, Method method, Object... args) throws Throwable &#123; // If the method is a method from Object then defer to normal invocation. if (method.getDeclaringClass() == Object.class) &#123; return method.invoke(this, args); &#125; if (platform.isDefaultMethod(method)) &#123; return platform.invokeDefaultMethod(method, service, proxy, args); &#125; ServiceMethod serviceMethod = loadServiceMethod(method); OkHttpCall okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args); return serviceMethod.callAdapter.adapt(okHttpCall); &#125; &#125;); &#125; 通过retrofit.create创建的对象，在执行相应的方法时都会经过这个内部类的invoke方法，再通过ServiceMethod 进行相关的请求。其实仔细想就明白了，每个网络请求其实并不关心叫什么名子，它只需要知道请求的url和参数就可以接着进行统一的网络请求就可以，所以看起来我们在定义接口的时候每个请求都定义了一个方法，但实际上这些方法没必要每个都实现。而这个ServiceMethod 内部不用看就知道肯定是会通过method来读取每个接口上的注解，以便知道该进行什么样的网络请求 动态代理类实现原理分析：可以看到，通过Proxy.newProxyInstance生成了一个继承通用接口的实例，调用它的方法时就会调用动态代理类InvocationHandler的invoke方法，那么这个类是实现的呢 1234567891011121314151617181920212223242526272829303132public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException &#123; Objects.requireNonNull(h); final Class&lt;?&gt;[] intfs = interfaces.clone(); //这里生成了一个继承通用接口的类 Class&lt;?&gt; cl = getProxyClass0(loader, intfs); try &#123; //可以发现这个类也有一个构造方法是传入InvocationHandler的 final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams); final InvocationHandler ih = h; if (!Modifier.isPublic(cl.getModifiers())) &#123; // Android-changed: Removed AccessController.doPrivileged cons.setAccessible(true); &#125; return cons.newInstance(new Object[]&#123;h&#125;); &#125; catch (IllegalAccessException|InstantiationException e) &#123; throw new InternalError(e.toString(), e); &#125; catch (InvocationTargetException e) &#123; Throwable t = e.getCause(); if (t instanceof RuntimeException) &#123; throw (RuntimeException) t; &#125; else &#123; throw new InternalError(t.toString(), t); &#125; &#125; catch (NoSuchMethodException e) &#123; throw new InternalError(e.toString(), e); &#125; &#125; 通过cl.getConstructor(constructorParams)可以看到创建的动态类是有构造方法是传入了InvocationHandler的生成这个类是应该是在getProxyClass0里面 123456 private static final WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt; proxyClassCache = new WeakCache&lt;&gt;(new KeyFactory(), new ProxyClassFactory());private static Class&lt;?&gt; getProxyClass0(ClassLoader loader, Class&lt;?&gt;... interfaces) &#123; return proxyClassCache.get(loader, interfaces); &#125; proxyClassCache很明显只是一个缓存用的对象，正直生成的地方应该就是ProxyClassFactory这个ProxyClassFactory内部收集完必要的信息后调用一个native方法生成并加载到内存的根据网上的资料，可以通过以下方法把这个类给弄出来 123456789byte[] classFile = ProxyGenerator.generateProxyClass("$Proxy0", PersonBean.class.getInterfaces()); String path = "G:/javacode/javase/Test/bin/proxy/StuProxy.class"; try(FileOutputStream fos = new FileOutputStream(path)) &#123; fos.write(classFile); fos.flush(); System.out.println("代理类class文件写入成功"); &#125; catch (Exception e) &#123; System.out.println("写文件错误"); &#125;]]></content>
      <tags>
        <tag>Retrofit</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gradle统一依赖]]></title>
    <url>%2F2018%2F03%2F11%2FGradle%E7%BB%9F%E4%B8%80%E4%BE%9D%E8%B5%96%2F</url>
    <content type="text"><![CDATA[在工程根目录下创建config.gradle文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//定义support包的版本号def supportVersion = "27.1.0"ext&#123; //定义各版本号 configs = [ compileSdkVersion: 27, buildToolsVersion: "25.0.2", miniSdkVersion: 17, targetSdkVersion: 27 ] libraries = [ appcompat : "com.android.support:appcompat-v7:$&#123;supportVersion&#125;", cardview : "com.android.support:cardview-v7:$&#123;supportVersion&#125;", recyclerview : "com.android.support:recyclerview-v7:$&#123;supportVersion&#125;", preference : "com.android.support:preference-v7:$&#123;supportVersion&#125;", supportv4 : "com.android.support:support-v4:$&#123;supportVersion&#125;", design : "com.android.support:design:$&#123;supportVersion&#125;", palette : "com.android.support:palette-v7:$&#123;supportVersion&#125;", constraintLayout : "com.android.support.constraint:constraint-layout:1.0.2", okhttp3 : "com.squareup.okhttp3:okhttp:3.10.0", okhttp3Logging : "com.squareup.okhttp3:logging-interceptor:3.10.0", gson : "com.google.code.gson:gson:2.8.2", retrofit : "com.squareup.retrofit2:retrofit:2.4.0", converterGson : "com.squareup.retrofit2:converter-gson:2.4.0", adapterRxjava : "com.squareup.retrofit2:adapter-rxjava2:2.4.0", glide : "com.github.bumptech.glide:glide:3.7.0", rxjava : "io.reactivex.rxjava2:rxjava:2.1.9", rxandroid : "io.reactivex.rxjava2:rxandroid:2.0.2", fastjson : "com.alibaba:fastjson:1.2.17", stetho : "com.facebook.stetho:stetho:1.3.1", stethoOkhttp3 : "com.facebook.stetho:stetho-okhttp3:1.3.1", rxlifecycleComponents:"com.trello.rxlifecycle2:rxlifecycle-components:2.2.1", butterknife : "com.jakewharton:butterknife:8.6.0", butterknifeCompiler : "com.jakewharton:butterknife-compiler:8.6.0", slidr : "com.r0adkll:slidableactivity:2.0.6", eventbus : "org.greenrobot:eventbus:3.1.1", eventbusCompiler : "org.greenrobot:eventbus-annotation-processor:3.1.1", junit : "junit:junit:4.12" ]&#125; 在根目录下的build.gradle文件顶部添加:1apply from: "config.gradle" 在各模块的build.gradle添加1234567891011android &#123; compileSdkVersion configs.compileSdkVersion buildToolsVersion configs.buildToolsVersion defaultConfig &#123; //省略其它配置 minSdkVersion configs.miniSdkVersion targetSdkVersion configs.targetSdkVersion &#125;&#125; 依赖添加: 12345678910111213141516171819202122232425262728293031323334353637383940414243dependencies &#123; //support相关包 compile libraries.appcompat compile libraries.design compile libraries.cardview compile libraries.recyclerview compile libraries.preference compile libraries.constraintLayout compile libraries.palette //rx compile libraries.rxjava compile libraries.rxandroid //okhttp compile libraries.okhttp3 //retrofit compile libraries.retrofit compile libraries.retrofitRxjava //gson compile libraries.gson compile libraries.converterGson //glide compile libraries.glide compile libraries.fastjson //stetho调试时使用 compile libraries.stetho compile libraries.stethoOkhttp3 //butterknife引用 compile libraries.butterknife annotationProcessor libraries.butterknifeCompiler //eventBus implementation libraries.eventbus annotationProcessor libraries.eventbusCompiler&#125;]]></content>
      <tags>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gradle/Groovy一览]]></title>
    <url>%2F2018%2F03%2F10%2FGradle-Groovy%E4%B8%80%E8%A7%88%2F</url>
    <content type="text"><![CDATA[参考资料 Gradle Plugin 用户使用指南 [Android Studio 自定义Gradle Plugin][https://www.jianshu.com/p/af2b0a43133f] Gradle 入门–只此一篇 给 ANDROID 初学者的 GRADLE 知识普及 深入理解Android之Gradle 重新认识AndroidStudio&amp;Gradle Gradle入门系列 官方文档 https://docs.gradle.org/current/dsl/ api文档： http://www.groovy-lang.org/api.html 简介Groovy是一种动态语言。它和Java一样，也运行于Java虚拟机中。几乎完全兼容JavaGradle提供了构建项目的一个框架，可以单独安装使用，安装地址https://gradle.org/install/ gradle-wrapper顾名思义，这表示是包装过的Gradle，Android工程中一般就的就是它，所以命令行执行的时候就会变成gradlew [task名称]，这里的gradlew，其实提指的就是工程根目录下的gradlew.bat和gradlew文件 如果工程里面没有gradle-wrapper，可以通过gradle wrapper生成 以下几个常用命令（注意Win系统下gradlew而linux系统下需要用./gradlew） ./gradlew -v 版本号 ./gradlew clean 清除9GAG/app目录下的build文件夹 ./gradlew build 检查依赖并编译打包这里注意的是 ./gradlew build 命令把 debug、release 环境的包都打出来，如果正式发布只需要打 Release 的包，该怎么办呢，下面介绍一个很有用的命令 assemble , 如 ./gradlew assembleDebug 编译并打Debug包 ./gradlew assembleRelease 编译并打Release的包 ./gradlew :app:dependencies --configuration compile 查看依赖关系 完成工程构建示例12345678910111213141516171819├── app #Android App目录，可改名，但需要在settings.gradle里面配置│ ├── app.iml│ ├── build #构建输出目录│ ├── build.gradle #构建脚本│ ├── libs #so相关库│ ├── proguard-rules.pro #proguard混淆配置│ └── src #源代码，资源等├── build│ └── intermediates├── build.gradle #工程构建文件├── gradle│ └── wrapper| ├── gradle-wrapper.jar| └── gradle-wrapper.properties #gradle的版本配置├── gradle.properties #gradle的配置├── gradlew #gradle wrapper linux shell脚本├── gradlew.bat #gradle wrapper window下的shell脚本├── local.properties #配置Androod SDK位置文件└── settings.gradle #工程配置 Gradle脚本写法 都以gradlew的写法为例 几个重要对象Project，Task ，ActionProject:是Gradle最重要的一个领域对象，我们写的build.gradle脚本的全部作用，其实就是配置一个Project实例。它里面有几个重要的成员变量和方法，例如: 123456rootProject //整个工程实例project //模块工程实例//两个用法一致，下面以project为例project.name //工程名称project.afterEvaluate&#123; &#125; //整个工程构建完成后执行，注意是构建，不是执行完成project.file("") //工程路径，里面接相对路程以获得文件对象 Task:被组织成了一个有向无环图（DAG）。Gradle中的Task要么是由不同的Plugin引入的，要么是我们自己在build.gradle文件中直接创建的可以通过gradlew tasks来查看有哪些任务task 定义task12345678task myTask &#123; doFirst &#123; println 'hello' &#125; doLast &#123; println 'world' &#125;&#125; 用以下命令执行 1gradlew myTask 这段代码的含义：给Project添加一个名为“myTask”的任务用一个闭包来配置这个任务,Task提供了doFirst和doLast方法来给自己添加Action。注意: 要执行的代码一定要放到doLast或者doFirst中，不会它会在任务构建完成前执行 12345//Test文件夹下建一个src目录，建一个dst目录，src目录下建立一个文件，命名为test.txttask copyFile(type: Copy)&#123; from "src" into "dst"&#125; 这是一个“显式地声明Task的类型“的方式 task的依赖关系12345678910111213task taskA &#123; doLast &#123; println 'this is taskA from project 1' &#125;&#125;task taskB &#123; doLast&#123; println 'this is taskB from project 1' &#125;&#125;taskB.dependsOn taskA 然后我们在命令行运行： 1gradle taskA 运行结果会先执行taskB的打印，然后执行taskA的打印 通过dependsOn 的依赖方式，可让我们已有的task后面添加任务，例如Maven的打包上传gradlew upload(不太确定是不是这个命令)和AndResGuard资源压缩就是通过依赖实现的 通过project.afterEvaluate{ }添加任务例如我们编译完成apk后，需要把apk，mapping等文件拷出来并重命名，但是又不想改变原有的命令例如新建文件copyApk.gradle 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152def outputPath = "./outApk/"def outApkDir = file(outputPath)if(!outApkDir.exists()) outApkDir.mkdir()import java.text.SimpleDateFormat/** * 获取Git 分支名 */def getGitBranch() &#123; try &#123; return 'git symbolic-ref --short -q HEAD'.execute().text.trim() &#125; catch (Exception e) &#123; return '' &#125;&#125;/** *组合最终需要的apk名称 *若要定制最终输出的文件名，请修改该方法 */def getTargetApkName()&#123; SimpleDateFormat format = new SimpleDateFormat("yyyyMMddHHmmss") def prefx = rootProject.name def today = format.format(new Date()) def versionName = android.defaultConfig.versionName return "$&#123;prefx&#125;_$&#123;getGitBranch()&#125;_v$&#123;versionName&#125;_$&#123;today&#125;"&#125;project.afterEvaluate &#123; def relaseTask = "assembleRelease" //assembleReleass任务后添加拷贝命令 if(tasks.findByName(relaseTask) != null)&#123; tasks.getByName(relaseTask) &#123; it.doLast &#123; println "$project.name: After assembleRelease, copy " def apkName = getTargetApkName() println "$&#123;apkName&#125;" copy&#123; from "/build/outputs/apk/release" into outputPath include "app-release-unsigned.apk" rename("app-release-unsigned.apk", "$&#123;apkName&#125;.apk") &#125; copy&#123; from "/build/outputs/mapping/release" into outputPath include "mapping.txt" rename("mapping.txt", "$&#123;apkName&#125;_mapping.txt") &#125; &#125; &#125; &#125;&#125; 在app模块的build.gradle的最下面引用该文件 1apply from: &quot;copyApk.gradle&quot; 一些方法的使用拷贝文件用copy方法 123456copy&#123;//拷贝maping文件 from "/build/outputs/mapping/release" //从哪个目录 into outputPath //拷贝到哪个目录 include "mapping.txt" //拷贝哪个文件，可以用通配符 rename("mapping.txt", "$&#123;apkName&#125;_mapping.txt") //重命名，不能用通配符&#125; 引入layoutlib.jar包该包下面有一些系统使用的类，但不建议引入（可以用反射） 1234567891011121314151617181920212223242526dependencies &#123; provided files(getLayoutLibPath())&#125;def getLayoutLibPath() &#123; def rootDir = project.rootDir def localProperties = new File(rootDir, "local.properties") def sdkDir = null if(localProperties.exists())&#123; Properties properties = new Properties() localProperties.withInputStream &#123; instr -&gt; properties.load(instr) &#125; sdkDir = properties.getProperty('sdk.dir') &#125; if(!sdkDir)&#123;//linux环境下的获取sdk的路径 sdkDir = System.getenv("ANDROID_HOME") &#125; if(sdkDir)&#123; def compileSdkVersion = android.compileSdkVersion Console.println("app compileSdkVersion : " + compileSdkVersion) def androidJarPath = sdkDir + "/platforms/" + compileSdkVersion + "/data/layoutlib.jar" return androidJarPath &#125; return rootDir&#125; 从AndroidManifest下面获取VersionName1234567//获取apk版本号def getVersionNameAdvanced(flavor)&#123; flavor = flavor ? flavor : "main" def xmlFile = project.file("./src/$flavor/AndroidManifest.xml") def rootManifest = new XmlSlurper().parse(xmlFile) return rootManifest['@android:versionName']&#125; 获取当前git的分支名12345678910/** * 获取Git 分支名 */def getGitBranch() &#123; try &#123; return 'git symbolic-ref --short -q HEAD'.execute().text.trim() &#125; catch (Exception e) &#123; return '' &#125;&#125; Groovy基础]]></content>
      <tags>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Stetho使用技巧]]></title>
    <url>%2F2018%2F03%2F04%2FStetho%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[Stetho是Facebook开源的一个Android应用的调试工具使用很简单而且也有很多资源介绍 参考资源Android开发调试神器Stetho介绍-只有你想不到没有你看不到 使用步骤1. 项目添加依赖。12compile "com.facebook.stetho:stetho:1.3.1"compile "com.facebook.stetho:stetho-okhttp3:1.3.1" 如果使用了okhttp，则需要添加第二个依赖 2. 初始化 Stetho123456public class MyApplication extends Application &#123; public void onCreate() &#123; super.onCreate(); Stetho.initializeWithDefaults(this); &#125;&#125; 3. 修改网络请求（可选）12new OkHttpClient.Builder() .addNetworkInterceptor(new StethoInterceptor()) .build() 4. 运行你的项目12在chrome中访问 chrome://inspect找到你的项目 点击 inspect 如果发现一直在转圈，需要先翻墙 使用技巧1. 动态加载开启Stetho在一般开发中我们通常是在debug版本下想入Stetho，而在release版本上去除，网资料大都是使用debugCompile的方式 1debugCompile 'com.facebook.stetho:stetho:1.3.1' 这样存在一个弊端是需要再在debug目录再添加一个Application 受同事启发，使用DexClassLoader动态加载的方式可以再方便的引入Stetho，并且不会影响apk的大小 首先新建一个app工程，引入Stetho依赖后，里面只需要添加一个类 1234567891011121314151617package com.aleaf.debug;import android.content.Context;import android.util.Log;import com.facebook.stetho.Stetho;public class StethoReflection &#123; private static final String TAG = "StethoReflection"; public void initStetho(Context context)&#123; Log.d(TAG,"initStetho context="+context); //chrome://inspect Stetho.initializeWithDefaults(context); &#125;&#125; 编译一个debug版的apk出来，并安装到手机上 在需要使用Stetho的app的Application里面使用DexClassLoader引入 12345678public class MApplication extends Application &#123; public void onCreate() &#123; //chrome://inspect if(BuildConfig.DEBUG)&#123;//debug版才开启 ReflectDebugUtil.reflectInitStetho(this); &#125; &#125;&#125; ReflectDebugUtil.java12345678910111213141516171819202122232425262728public class ReflectDebugUtil &#123; public static final String DEBUG_PACKGE = &quot;com.aleaf.debug&quot;; public static final String DEBUG_STETHO_CLASS_NAME = &quot;com.aleaf.debug.StethoReflection&quot;; private void reflectInitStetho(Context context)&#123; try &#123; Context stethoContext = context.createPackageContext( DEBUG_PACKGE, Context.CONTEXT_INCLUDE_CODE | Context.CONTEXT_IGNORE_SECURITY); String outDir = context.getFilesDir() + File.separator + &quot;debug&quot;; if(!new File(outDir).exists())&#123; new File(outDir).mkdirs(); &#125; DexClassLoader dexLoader = new DexClassLoader( stethoContext.getApplicationInfo().sourceDir,//dst apk surce path outDir,// context.getApplicationInfo().nativeLibraryDir,//.so context.getClassLoader()); Class&lt;?&gt; clazz = dexLoader.loadClass(DEBUG_STETHO_CLASS_NAME); Object ste = clazz.newInstance(); Method m = clazz.getMethod(&quot;initStetho&quot;,Context.class); m.invoke(ste,context); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 这样做的好处时应用apk完全不需要引入Stetho的sdk，打开关闭调试也很方便，只需要安装卸载debug的apk即可]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 Windows 平台上打造出你的 Linux 开发环境]]></title>
    <url>%2F2018%2F03%2F04%2F%E5%9C%A8-Windows-%E5%B9%B3%E5%8F%B0%E4%B8%8A%E6%89%93%E9%80%A0%E5%87%BA%E4%BD%A0%E7%9A%84-Linux-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[资料： 在 Windows 平台上打造出你的 Linux 开发环境 Cmder简单使用小结 Win下必备利器之Cmder Cmder官网地址: http://cmder.net/cmder有两个版本，mini版和full版mini版本，就几M大小，这个也就用来替代windows的cmdfull版本比较大，100多M，模拟了一些常用linux命令（比如ls、cat、more、cp、mv、rm、find、grep等），自带git,而且自带vim。（如果已经安装了git for windows可以只使用mini版，但是要把git的src/bin添加到path中去） 快捷键 start . 或者e. 打开当前路径所在的文件夹 Alt+H ：显示所有快速键清单 自定义aliases打开Cmder目录下的config文件夹，里面的aliases文件就是我们可以配置的别名文件，只需将里面ls命令的别名按下列方式修改就可以在ls命令下显示中文。 例如：12ll=ls -la --show-control-chars -F --color $*la=ls -a --show-control-chars -F --color $* 启动Cmder因为她是即压即用的存在，所以点击Cmder.exe即可运行。很显然这般打开她，不怎么快捷，即便用Listary高效搜索到她，然后点击;我们可以这样做: 把 cmder 加到环境变量可以把Cmder.exe存放的目录添加到系统环境变量；加完之后,Win+r一下输入cmder,即可。 添加 cmder 到右键菜单在某个文件夹中打开终端, 这个是一个(超级)痛点需求, 实际上上一步的把 cmder 加到环境变量就是为此服务的, 在管理员权限的终端输入以下语句即可: 1Cmder.exe /REGISTER ALL 添加命令(配合listary)在选项-命令中，添加一个命令，关键字填cmder,路径填cmder.exe(需要添加到环境变量中)，参数填/START %path%,这样在任意地方输入cmder就能在当前路径打开cmder了 添加右键可以关注这个gist。在Cmder根目录新建一个init.bat，输入以下代码：1234567@echo offSET CMDER_ROOT=%~dp0reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Directory\Background\shell\Cmder" /ve /d "Cmder Here" /freg add "HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Directory\Background\shell\Cmder" /v "Icon" /d "\"%CMDER_ROOT%cmder.exe\"" /freg add "HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Directory\Background\shell\Cmder" /v "Extended" /freg add "HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Directory\Background\shell\Cmder\command" /ve /d "\"%CMDER_ROOT%cmder.exe\" \"%%V\"" /fpause 以管理员身份运行init.bat即可。删除的话再在根目录新建一个uninit.bat，依然是以管理员身份运行。代码如下：123@echo offReg delete &quot;HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Directory\Background\shell\Cmder&quot; /fpause 解决文字重叠问题Win + Ait + P 唤出设置界面 &gt; mian &gt; font &gt; monospce,去掉那勾勾即可 修改命令提示符号·λ·Cmder预设的命列列提示符号是 λ ;如果用着不习惯，可以将这个字元改成Mac / Linux环境下常见的 $ 符号，具体操作如下： 编辑Cmder安装目录下的vendor\init.bat批处理文件(min版本15行)，把：1@prompt $E[1;32;40m$P$S&#123;git&#125;&#123;hg&#125;$S$_$E[1;30;40m &#123;lamb&#125; $S$E[0m 修改成以下即可：1@prompt $E[1;32;40m$P$S&#123;git&#125;&#123;hg&#125;$S$_$E[1;30;40m $$ $S$E[0m 这个亲测在cmder.exe可以，但在PowerShell.exe需要另行设置: 打开文件config/cmder.lua（prompt.lua也有版本是这个），将第二行中的 λ 修改为Linux下常用的 $ 即可；亲测可行(2016-01-13)。 Chocolatey软件包管理系统Chocolatey的哲学就是完全用命令行来安装应用程序，它更像一个包管理工具（背后使用 Nuget ）安装chocolatey , 运行如下命令即可： @powershell -NoProfile -ExecutionPolicy unrestricted -Command &quot;iex ((new-object net.webclient).DownloadString(&apos;https://chocolatey.org/install.ps1&apos;))&quot; &amp;&amp; SET PATH=%PATH%;%ALLUSERSPROFILE%\chocolatey\bin 可能需要被墙了，需要挂代理安装软件命令 choco install softwareName, 短写是 cinst softwareName可安装的应用程序，可以参见其 Package列表以下是window下开发常用的开发环境应用:12345678910111213choco install autohotkey.portable #安装 AutoHotkey (Portable)choco install nodejs.install #安装 nodechoco install git.install #安装 gitchoco install ruby #安装 rubychoco install python #安装 pythonchoco install jdk8 #安装 JDK8choco install googlechrome #安装 Chromechoco install google-chrome-x64 #Google Chrome (64-bit only) choco install firefox #安装 firefoxchoco install notepadplusplus.install #安装 notepad++choco install Atom #安装 Atomchoco install SublimeText3 #安装 SublimeText3choco install wget]]></content>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub+Hexo搭建博客笔记]]></title>
    <url>%2F2018%2F03%2F04%2FGitHub-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[参考资料GitHub+Hexo 搭建个人网站详细教程 搭建步骤：获得个人网站域名 GitHub创建个人仓库 安装Git 安装Node.js 安装Hexo 推送网站 绑定域名 更换主题 初识MarkDown语法 发布文章 寻找图床 个性化设置 其他 附录 Github上创建一个仓库名称为：aleaf.github.io 安装Node.jsHexo基于Node.js，Node.js下载地址：Download | Node.js 下载安装包，注意安装Node.js会包含环境变量及npm的安装，安装后，检测Node.js是否安装成功，在命令行中输入 node -v : 安装Hexo使用npm命令安装Hexo，输入：1npm install -g hexo-cli 安装完成后，初始化我们的博客，输入：1hexo init blog 为了检测我们的网站雏形，分别按顺序输入以下三条命令： 12345hexo new test_my_sitehexo ghexo s 这些命令在后面作介绍，完成后，打开浏览器输入地址：1localhost:4000 常用命令:123456789101112131415npm install hexo -g #安装Hexonpm update hexo -g #升级 hexo init #初始化博客命令简写hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章hexo g == hexo generate #生成hexo s == hexo server #启动服务预览hexo d == hexo deploy #部署hexo server #Hexo会监视文件变动并自动更新，无须重启服务器hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IPhexo clean #清除缓存，若是网页正常情况下可以忽略这条命令 推送网站打开站点的配置文件_config.yml，翻到最后修改为： 1234deploy: type: git repo: git@github.com:ToryCrox/aleaf.github.io.git branch: master 保存站点配置文件 1npm install hexo-deployer-git --save 这时，我们分别输入三条命令： 123hexo clean hexo g hexo d hexo配置Next主题配置官方文档 主题配置 - NexT 使用文档 第三方服务集成 - NexT 使用文档 内置标签 - NexT 使用文档 进阶设定 - NexT 使用文档 个性个配置 hexo的next主题个性化配置教程 更换主题theme下载：https://hexo.io/themes/ 1git clone https://github.com/iissnan/hexo-theme-next themes/next 打开站点_config.yml文件，配置主题为next: 1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next 打开主题的_config.yml配置文件，不是站点主题文件，找到Scheme Settings：next主题有三个样式，使用是Pisces 设置为中文找到主题的_config.yml，修改 1language: zh-Hans 个性化配置主要个性主题配置文件_config.yml 社交主页设置, 找到social12social: GitHub: https://github.com/ToryCrox 增加侧栏菜单条目默认的侧栏菜单条目有：首页、归档、标签、关于、搜索等。如果你想要增加其他的菜单条目，修改主题配置文件_config.yml里的Menu Settings中的menu和menu_icons两个地方 设置侧栏的位置:修改 主题配置文件 中的 sidebar 字段:12sidebar: position: left 见:http://theme-next.iissnan.com/getting-started.html#sidebar-settings 启用搜索功能自定义站点内容搜索Local Search 安装 hexo-generator-searchdb，在站点的根目录下执行以下命令： 1$ npm install hexo-generator-searchdb --save 编辑 站点配置文件，新增以下内容到任意位置： 12345search: path: search.xml field: post Toggle strikethrough format: html limit: 10000 编辑 主题配置文件，启用本地搜索功能： 123# Local searchlocal_search: enable: true 添加标签页面 使用命令新建一个标签页面 1hexo new page tags 编辑刚新建的页面，将页面的类型设置为 tags ，主题将自动为这个页面显示标签云。页面内容如下： 123title: 标签date: 2014-12-22 12:39:04type: "tags" 修改菜单，编辑主题配置文件 ， 添加 tags 到 menu 中 1234menu: home: / archives: /archives tags: /tags 主题配置 - NexT 使用文档 编辑刚新建的页面，将页面的类型设置为 tags ，主题将自动为这个页面显示标签云。页面内容如下： 123title: 标签date: 2014-12-22 12:39:04type: &quot;tags&quot; 修改菜单，编辑主题配置文件 ， 添加 tags 到 menu 中 1234menu: home: / archives: /archives tags: /tags 让首页不显示全文有两种方法，参考: Hexo Next 阅读全文设置 Next主题怎么让首页不显示全文 themes/next 目录下的 _config.yml 文件，找到这段代码 12345# Automatically Excerpt. Not recommend.# Please use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt: enable: false length: 150 把 enable 的 false 改成 true 就行了，然后 length 是设定文章预览的文本长度 写 md 文章的时候，可以在内容中加上 &lt;!--more--&gt;，这样首页和列表页展示的文章内容就是 &lt;!--more--&gt; 之前的文字，而之后的就不会显示了。 虽然第一种方法配置简单，但是显示的预览会乱，所以我选第二种方法 设置首页文章数量首页默认显示10篇文章，会导致首页很长，可以在站点_config.yml文件中，搜索per_page，修改显示数量12345678# Home page setting# path: Root path for your blogs index page. (default = '')# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator: path: '' per_page: 5 order_by: -date 参考: Hexo程序archive页面数量设置]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
